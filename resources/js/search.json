[[{"l":"Introduction","p":["Nexus est un outil qui se veut être un gestionnaire de projet Python complet. L'objectif est de centraliser l'ensemble des besoins d'un développeur Python au même endroit pour faciliter son utilisation et limiter la nécessité d'installer de multiples outils.","A l'instar de Poetry, Nexus se positionne comme un gestionnaire de dépendances et de packaging. Le tout accompagné d'un système d'environnement virtuel pour isoler les différents environnements de travail.","L'outil propose également des outils d'analyse et de mise en conformité de votre code grâce à l'intégration de pylint, bandit et black.","L'implémentation de cx_freeze permet de compiler son code en version portable.","Un système de repository interne et de backup permet de versionner proprement son code et de réaliser les sauvegardes pour réaliser des archives."]}],[{"l":"Architecture","p":["Nexus propose une architecture équivalente à ce qu'on peut retrouver sur une solution comme Poetry et apporte quelques modifications mineures pour s'adapter au besoin de la solution et des outils utilisés."]}],[{"l":"Concept","p":["Un projet Nexus contient plusieurs éléments:","Un fichier nexus.toml qui contient la configuration du projet","Un fichier README.md","Un fichier LICENSE (si demandé)","Un fichier changelog.md (si demandé)","Le répertoire qui va contenir le code du projet (et le fichier principal demandé lors de la création du projet)"]}],[{"i":"nexustoml","l":"Nexus.toml","p":["Le fichier nexus.toml contient l'ensemble des informations et des paramètres qui seront nécessaire pour le bon fonctionnement de Nexus. Ces paramètres sont regroupés par section pour une meilleure compréhension.","Il est possible de retrouver facilement les informations d'un projet avec la commande project"]},{"l":"Description des sections"},{"l":"Section project","p":["Contient les éléments de base sur la description du projet","name: le nom du projet version: la version actuelle description: la description du projet mainfile: le fichier principal qui sera utilisé pour l'exécution du code ou encore la compilation du projet requires-python: les prérequis de version Python"]},{"i":"section-projectmetadata","l":"Section project.metadata","p":["Contient les métadonnées qui seront utilisées pour rendre notre projet publiable.","authors: Les auteurs du projet (sous forme de liste) maintainers: Les mainteneurs du projet (sous forme de liste) readme: l'emplacement du fichier readme.md (pour la description principale qui sera utilisée) license: le type de licence utilisée license_file: l'emplacement du fichier de licence keywords: les mots-clés qui seront définis pour rechercher le package dans les repo classifiers: même remarque que keywords copyright: pour spécifier d'éventuels copyright changelog: l'emplacement du fichier de changelog"]},{"i":"section-projecturls","l":"Section project.urls","p":["Contient les liens utiles affichés sur les repo","changelog: l'url vers le fichier de changelog homepage: l'url vers la page d'accueil du projet documentation: l'url vers la documentation"]},{"i":"section-projectdependencies","l":"Section project.dependencies","p":["Contient l'ensemble des dépendances du projet avec comme format NOM_PACKAGE = \"VERSION\"","Des sous-sections windows et linux sont possibles pour préciser des dépendances spécifiques au système."]},{"i":"section-projectbuild","l":"Section project.build","p":["Contient les différentes informations qui seront utiles pour la création de package et la compilation.","packages: La liste des packages natif ou à installer nécessaire au projet includes: la liste des modules internes au projet nécessaires excludes: La liste des packages à exclure include_files: La liste des fichiers annexes à intégrer au projet optimize: niveau d'optimisation de la compilation (0 (disabled), 1 or 2) no_compress: booléen qui définit si les dépendances sont dans fichier zip sans compression lors de la compilation GUI: booléen qui définit si le projet a une partie graphique icon: chemin vers le fichier icon qui sera utilisé par l'application compilée"]},{"i":"section-projectwheel","l":"Section project.wheel","p":["Contient les informations spécifiques pour la création de package","platforms: précise la plateforme nécessaire Une sous-sectoin entry_points contient console_scripts qui contient la liste des console_scripts qui seront créés avec notre package."]}],[{"l":"Configuration","p":["La configuration Nexus est un ensemble de paramètres qui sont applicables à l'ensemble des projets et qui permettent de contrôler certains comportements comme les environnements virtuels, les repos ou encore l'affichage de logs.","Pour voir l'ensemble des paramètres configurés, il suffit d'appeler la commande config","Les paramètres booléen: Qui sont modifiables simplement en donnant le nom du paramètre dans l'appel de la commande","Les paramètres à valeur: Qui sont modifiables en donnant le nom du paramètre suivi de la valeur souhaitée (en comptant que certains paramètres doivent être des nombres)"]},{"l":"Désactivation de paramètre","p":["Pour des besoins ponctuels, il est possible de désactiver ces paramètres avec l'argument --disable. Ces paramètres seront alors encore présent dans la configuration mais ne seront plus appliqué jusqu'à réactivation.","et de les réactiver avec l'argument --enable"]},{"l":"Recharger la configuration","p":["Dans le cas de configuration corrompue ou erronée, il est possible de recharger la configuration avec ces paramètres par défaut avec l'argument --reload"]},{"l":"Description des paramètres","p":["Ces paramètres sont regroupés en catégories (general, virtualenvs, logs, project, publish, repo). Chacun agit sur un ou plusieurs composants."]},{"l":"general","p":[": Défini l'emplacement du répertoire de cache: Configuration d'un proxy pour les commandes ayant besoin d'internet: Active l'utilisation de multi-thread pour les traitements: Défini le nombre maximum de thread parallèle"]},{"l":"virtualenvs","p":["Ces paramètres seront utilisés pour la création d'un environnement virtuel.",": Création d'un environnement virtuel au moment de la création ou de l'initialisation d'un projet: Nettoie le paramètre de l'environnement s'il existe déjà: Met à jour pip au moment de la création: Stocke l'environnement dans le projet (sinon dans le cache): Utilise des liens symboliques au lieu de copier les fichiers: Autorise l'utilisation des site-packages système: Nom du répertoire des environnements: Défini le modèle de prompt qui sera utilisé dans l'environnement"]},{"l":"logs","p":["Ces paramètres seront utilisés pour définir le niveau de logs souhaité.",": Affiche les logs de l'application: Affiche les logs détaillés: Ajoute la date dans les logs: Affiche les logs en version truecolor"]},{"l":"project","p":["Ces paramètres seront utilisés pour délimiter le comportement du projet.",": Alimentation d'un changelog en cas de changement de version: Niveau de recherche pour déterminer si on se trouve dans un projet"]},{"l":"publish","p":["Ces paramètres seront utilisés pour publier des packages sur un repo.",": URL du repo de package: Nom de l'utilisateur utilisé"]},{"l":"metadata","p":["Ces paramètres seront utilisés pour définir le comportement lors de la recherche de métadonnées sur un package.",": URL du repo sur lequel chercher les métadonnées"]},{"l":"repo","p":["Ces paramètres seront utilisés pour définir le comportement du repo de projet.",": Initialisation d'un repo en même temps que la création ou l'initialisation d'un projet: Défini le modèle de message qui sera utilisé pour les commit: Activation du changement de branche automatique en cas de changement de version du projet"]}],[{"l":"Project Management","p":["Nexus propose une solution complète pour gérer l'ensemble de son projet Python sans avoir besoin de basculer entre plusieurs solutions ou de modifier des fichiers de configuration non essentiel."]}],[{"i":"création-dun-projet","l":"Création d'un projet","p":["Nexus propose de créer très rapidement un nouveau projet qui se base sur la structure décrite dans la partie concept. Pour cela, on utilise la commande new","Plusieurs informations seront demandées:","Le nom du projet","La version d'origine","La description du projet","Le fichier principal","Le nom de l'auteur","Le nom du mainteneur","La licence choisie (les informations nécessaires à la création de la licence)","Les dépendances nécessaires","Certaines de ces informations comme maintainers ne sont pas obligatoire pour la création du projet.","Une fois les informations renseignées, le projet sera créé et les différents composants tels que l'environnement virtuel et le repo seront créés en fonction des paramètres configurés."]},{"l":"Options","p":["La majorité de ces options se retrouve dans la configuration Nexus met propose d'être dissocié et donc d'être appliqué uniquement sur la création de ce projet.","pour créer un environnement virtuel pour ne pas créer d'environnement virtuel pour supprimer le répertoire de l'environnement si non vide pour mettre à jour pip au moment de la création pour placer l'environnement dans le répertoire du projet pour placer l'environnement dans le répertoire de cache pour spécifier le répertoire de l'environnement pour créer un repo dans le projet pour ne pas créer un repo dans le projet"]}],[{"l":"Initialisation à partir de code existant","p":["Dans le cas où vous avez déjà des projets existants, il est possible de le \"convertir\" en projet Nexus pour être géré par la suite par cette solution.","Plusieurs informations seront demandées:","Le nom du projet","La version d'origine","La description du projet","Le fichier principal","Le nom de l'auteur","Le nom du mainteneur","La licence choisie (les informations nécessaires à la création de la licence)","Certaines de ces informations comme maintainers ne sont pas obligatoire pour la création du projet. Le système va se baser sur un système d'analyse du code pour retrouver la liste des dépendances nécessaires.","Une fois les informations renseignées, le projet sera initialisé et les différents composants tels que l'environnement virtuel et le repo seront créés en fonction des paramètres configurés."]},{"l":"Options","p":["La majorité de ces options se retrouve dans la configuration Nexus met propose d'être dissocié et donc d'être appliqué uniquement sur la création de ce projet.","pour créer un environnement virtuel pour ne pas créer d'environnement virtuel pour supprimer le répertoire de l'environnement si non vide pour mettre à jour pip au moment de la création pour placer l'environnement dans le répertoire du projet pour placer l'environnement dans le répertoire de cache pour spécifier le répertoire de l'environnement pour créer un repo dans le projet pour ne pas créer un repo dans le projet"]}],[{"l":"Versioning","p":["Nexus propose un système de versioning simplifié pour rapidement prendre en compte une version de package. Par défaut, la commande sans argument affichera la version actuelle du projet.","Plusieurs arguments sont possibles pour changer la version du projet actuelle:","Donner le nom de version souhaité","Spécifier l'alias (major, minor ou patch). Dans ce cas, le numéro de version sera calculé automatiquement En fonction de la configuration du projet, plusieurs autres actions seront réalisés.","Si un repo est configuré, une nouvelle branche sera créé avec la nouvelle version","Si le fichier de changelog est configuré, les informations seront demandés pour les ajouter au changelog"]}],[{"l":"Ajout de package","p":["Pour gérer les dépendances d'un projet, vous pouvez utiliser la commande pour ajouter des dépendances au projet.","Ces dépendances seront alors ajoutés à la configuration du projet."]},{"l":"Options","p":["pour ajouter les dépendances uniquement pour Windows pour ajouter les dépendances uniquement pour Linux installer les dépendances ajoutées. Dans ce cas un contrôle de compatibilité entre les dépendances et les packages déjà installés sera effectué pour éviter les conflits pour forcer l'installation ou pour spécifier un fichier de requirement ou pour spécifier l'environnement sur lequel installer les packages"]}],[{"l":"Suppression de package","p":["Pour gérer les dépendances d'un projet, vous pouvez utiliser la commande pour supprimer des dépendances au projet.","Ces dépendances seront alors supprimées à la configuration du projet."]},{"l":"Options","p":["pour supprimer les dépendances uniquement pour Windows pour supprimer les dépendances uniquement pour Linux désinstaller les dépendances supprimées ou pour spécifier l'environnement sur lequel désinstaller les packages"]}],[{"l":"Vérification du projet","p":["Nexus propose une solution de vérification du projet. Grâce à cela, plusieurs éléments seront vérifiés:","Analyse des dépendances du projet: Les dépendances présents dans la configuration du projet seront analysés pour garantir","Analyse des dépendances inutiles: Une analyse du code et de la configuration du projet sera effectuée pour trouver les dépendances qui seraient configurées mais non utilisées dans le code.","Analyse des nouvelles dépendances: Une analyse du code et de la configuration du projet sera effectuée pour trouver les dépendances utilisées dans le code mais non configurées dans le projet.","Vérification des informations de build: Une analyse du code et de la configuration du projet sera effectuée pour trouver les configurations de packaging et de compilation qui seraient incomplètes.","ou permet de spécifier l'environnement utilisé"]}],[{"l":"Environment Management","p":["Nexus propose un système d'environnement virtuel. Un environnement virtuel Python est un espace isolé et autonome dans lequel vous pouvez installer des paquets, dépendances et versions spécifiques de Python pour un projet donné. Ce mécanisme vous permet de maintenir différentes configurations et dépendances de packages pour différents projets, sans interférer avec d'autres environnements Python.","Pour la création de ces environnements, l'outil utilise l'utilitaire virtualenv","L'exécution de la commande sans argument tentera d'ouvrir l'environnement virtuel par défaut","Pour travailler sur ces projets, Nexus va toujours regarder dans le fichier de configuration du projet si un environnement par défaut est configuré, si c'est le cas il lancera ces actions dessus, dans le cas contraire, il lancera ces actions sur le python racine."]}],[{"l":"Environnement par défaut","p":["Dans la majorité des commandes, Nexus tentera de retrouver dans le fichier de configuration du projet si un environnement par défaut est configuré, si c'est le cas il lancera ces actions dessus, dans le cas contraire, il lancera ces actions sur le python racine."]},{"l":"Définir en environnement par défaut","p":["L'argument permet de définir l'environnent par défaut."]},{"i":"désactiver-lenvironnement-par-défaut","l":"Désactiver l'environnement par défaut","p":["L'argument supprime la mention par défaut sur un environnement."]}],[{"i":"création-dun-environnement","l":"Création d'un environnement","p":["Pour la création d'un environnement virtuel, nous utilisons l'argument env --create","Il faudra à minima préciser le nom de l'environnement","Dans la configuration Nexus, il existe des paramètres qui sont utilisés pour définir le comportement lors de la création des environnements."]},{"l":"Options","p":["ou pour définir ce nouvel environnement comme l'environnement par défaut pour définir si les dépendances du projet doit être installés au moment de la création de l'environnement pour définir si le dossier de l'environnement doit être nettoyer si non vide lors de la création ou pour forcer la création de l'environnement dans le dossier de cache ou pour définir le prompt dans l'environnement"]}],[{"l":"Sandbox","p":["Pour réaliser des tests sur l'instant, Nexus propose la création de sandbox qui sont créée en direct et qui sont supprimées lors de la sortie de l'environnement.","Cet environnement fonctionne comme un environnement classique. Il est possible d'installer/supprimer des packages, exécuter des commandes ou encore ouvrir un prompt."]}],[{"l":"Ajouter un environnement existant","p":["Il est possible d'assigner un environnement existant à un projet","Il faudra à minima préciser le chemin vers l'environnement"]},{"l":"Options","p":["définie le nom de l'environnement ou pour définir ce nouvel environnement comme l'environnement par défaut"]}],[{"l":"Cloner un environnement","p":["Il est possible de cloner un environnement virtuel existant avec l'ensemble des paramètres et dépendances de celui-ci","Il faudra préciser le nom de l'environnement existant et le nom du nouvel environnement."]}],[{"i":"migration-denvironnement","l":"Migration d'environnement","p":["Il est possible de migrer un environnement virtuel du cache vers le projet ou inversement","Il faudra à minima préciser le nom de l'environnement"]},{"l":"Options","p":["ou définie le chemin de destination de l'environnement"]}],[{"l":"Lister les environnements","p":["Il est possible de lister les environnements virtuels d'un projet avec l'argument","La commande nous affichera la liste des venv mais également si c'est un environnement par défaut, s'il est stocké dans le cache ou encore si les fichiers de l'environnement n'existe plus"]}],[{"l":"Supprimer un environnement","p":["Il est possible de supprimer un environnement virtuel d'un projet. Dans ce cas, le projet sera supprimé du fichier de configuration du projet et les fichiers de l'environnement seront effacés.","Il faudra à minima préciser le nom de l'environnement"]}],[{"l":"Travail dans un environnement","p":["Il existe plusieurs solutions pour travailler dans un environnement virtuel, ouvrir un environnement, ouvrir le prompt Python ou encore exécuter une commande dans l'environnement.","Entrer dans un environnement virtuel Python signifie configurer votre terminal ou votre invite de commande pour utiliser l'installation Python et les dépendances spécifiques à cet environnement virtuel. Cela isole l'environnement virtuel, garantissant que les commandes Python et les exécutions de scripts utilisent les packages installés dans cet environnement spécifique."]},{"l":"Entrer dans un environnement","p":["Deux méthodes, utiliser la commande nxs env sans aucun paramètre ouvrira l'environnement par défaut","Pour entrer dans un environnement spécifique, il faudra utiliser l'argument"]},{"l":"Ouvrir le prompt Python","p":["La commande shell va permettre d'ouvrir directement le prompt Python de l'environnement virtuel sans passer par la phase d'entrée dans l'environnement.","Sans paramètre, la commande va ouvrir l'environnement par défaut Pour ouvrir un shell d'un environnement spécifique, il faudra utiliser l'argument ou"]},{"l":"Exécuter une commande ou script","p":["Nexus propose d'exécuter une commande directement dans un environnement sans l'ouvrir.","Il est également possible d'exécuter un fichier .py"]},{"l":"Options","p":["Par défaut, la commande utilisera l'environnement par défaut. Pour utiliser un environnement spécifique, il faudra utiliser l'argument ou","Pour faciliter les tests, il est possible de définir des paramètres qui seront utilisés lors de l'exécution par la commande","Ces paramètres seront stockés dans le fichier du projet et seront utilisés au lancement de la commande run","Il est également possible de dissocier les exécutions de test (avec ) et de prod (avec ) pour permettre de réaliser différents tests rapidement","Pour contrôler les temps d'exécutions, l'option ou permet d'afficher le temps de la commande ou du script"]}],[{"l":"Package Management","p":["La partie gestion des packages est l'élément le plus important dans la création du projet. C'est grâce à ces composants que nous pourrons installer/supprimer/mettre à jour nos dépendances pour garantir que nos projets fonctionneront correctement et qu'ils pourront être compilés pour les rendre portable. En plus de cela, Nexus propose un système qui va garantir la compatibilité entre chaque package installé pour s'assurer d'avoir le maximum de stabilité et pour limiter les conflits de code.","FORMAT DES VERSIONS"]}],[{"l":"Chercher un package","p":["Nexus propose une option pour rechercher un package qui pourra être installé par la suite","Cette commande retourne une liste de package disponible qui correspondent avec leur dernière version disponible et leur description. L'option permet d'afficher uniquement les packages dont le nom correspond exactement."]}],[{"l":"Lister les packages installés","p":["La solution propose une commande pour lister l'ensemble des packages installés sur un environnement.","La commande retournera une liste de package avec leur version."]}],[{"i":"information-dun-package","l":"Information d'un package","p":["Il est possible d'afficher les informations d'un package","Cette commande affichera:","Le nom du package","La dernière version du package","La description","Le nom de licence","L'url de la homepage","L'arborescence des dépendances","Les vulnérabilités identifiées","Indique si le package est installé et sa localisation","Dans ce cas où l'argument est un fichier de package, la commande retournera l'ensemble des métadonnées contenues dans le fichier."]},{"l":"Options","p":["pour ne pas afficher l'arborescence des dépendances pour définir le niveau de recherche de l'arborescence des dépendances pour afficher la liste des versions disponibles"]}],[{"l":"Installation de package","p":["Nexus propose d'installer des packages tout en contrôlant la compatibilité avec les packages déjà installés.","Dans le cas où nous nous trouvons dans un projet, la commande tentera de trouver un environnement par défaut disponible, sinon fera les installations sur la racine Python.","Dans le cas où nous nous trouvons dans un projet et que nous ne précisons pas de package, la commande va récupérer la liste des dépendances du projet et tenter de les installer."]},{"l":"Options","p":["ou pour forcer l'installation d'un package ou pour installer des packages depuis un fichier requirements ou pour spécifier l'environnement sur lequel installer les packages"]}],[{"l":"Désinstallation de package","p":["Nexus propose de désinstaller des packages.","Dans le cas où nous nous trouvons dans un projet, la commande tentera de trouver un environnement par défaut disponible, sinon désinstallera les packages sur la racine Python.","Dans le cas où nous nous trouvons dans un projet et que nous ne précisons pas de package, la commande va récupérer la liste des dépendances du projet et tenter de les désinstaller."]},{"l":"Options","p":["ou pour spécifier l'environnement sur lequel désinstaller les packages"]}],[{"l":"Mise à jour de package","p":["La solution propose de mettre à jour l'ensemble ou une partie des packages d'un environnement.","Dans le cas où nous nous trouvons dans un projet, la commande tentera de trouver un environnement par défaut disponible, sinon mettra à jour les packages sur la racine Python.","Dans le cas où nous nous trouvons dans un projet et que nous ne précisons pas de package, la commande va récupérer la liste des dépendances du projet et tenter de les mettre à jour."]},{"l":"Options","p":["ou pour spécifier l'environnement sur lequel mettre à jour les packages. ou pour permettre de tester les mises à jour sur un environnement isolé. ou pour mettre à jour l'ensemble des packages d'un environnement."]}],[{"l":"Gestion des alias","p":["Il est possible que certains packages ont un nom différent entre le nom publié et le nom des module à installer. C'est par exemple le cas avec le package py-cpuinfo qui doit être importé avec comme nom cpuinfo. Dans ce cas, Nexus propose un système d'alias qui permet de faire une correspondance entre le nom publié et le nom d'import","Un fichier .package_alias sera alors créé à la racine du projet avec l'ensemble des alias.","L'appel de la commande sans argument affichera les alias actuellement configurés.","ou pour ajouter un alias avec le nom de l'alias et du package ou pour supprimer un alias avec le nom de l'alias pour ajouter l'alias uniquement pour Windows pour ajouter l'alias uniquement pour Linux"]}],[{"l":"Snapshot","p":["Dans l'objectif de gagner en stabilité et en liberté, Nexus propose un système de snapshot qui permet de sauvegarder l'état actuelle des dépendances et de leur version dans l'objectif de restaurer l'état d'un environnement ou pour l'injecter dans un nouvel environnement.","Par défaut, le snapshot sera stocké dans un fichier snap.json"]},{"l":"Options","p":["ou pour spécifier l'environnement a utiliser ou pour spécifier le fichier de sortie pour restaurer un snapshot pour forcer la restauration"]}],[{"l":"Verrouillage de version","p":["Pour garantir de toujours utiliser les bonnes versions de dépendances entre environnement, il est possible de verrouiller les versions sur un projet en générant un fichier de lock nexus.lock Grâce à cela, les dépendances qui ont été verrouillées seront installées uniquement dans la version définie dans le fichier de lock.","Pour définir les versions de lock, la commande se base sur les versions installées sur l'environnement utilisé.","Il est possible d'ajouter un paramètre le nom des package qui doivent être verrouillés. Dans le cas contraire, l'ensemble des dépendances du projet seront verrouillées."]},{"l":"Options","p":["ou permet de spécifier l'environnement utilisé"]}],[{"l":"Packaging","p":["Nexus propose un système pour faire un package du projet en cours en .whl et/ou .tar.gz pour ensuite être publié sur les repo.","Une fois la commande lancée, la système va réaliser un package et le placer dans le répertoire dist du projet."]},{"l":"Options","p":["pour créer un package pour Windows pour créer un package pour Linux pour créer un package .tar.gz ou pour afficher les informations de packaging sans action"]}],[{"l":"Publication","p":["Nexus propose une solution pour publier ces packages sur le repo de notre choix (par défaut pypi.org)"]},{"l":"Options","p":["permet de préciser l'url du repo cible","Une autre méthode pour définir le repo cible est de changer le paramètre publish.url dans la configuration Nexus. Il est également possible de paramétrer le compte qui publie avec le paramètre publish.username dans la configuration Nexus."]}],[{"l":"Provisioning","p":["Dans la majorité des repo Python, il est d'usage d'associer un nom de package au profil de son propriétaire. C'est-à-dire que seul celui-ci pourra ajouter ou mettre à jour un package portant ce nom, même si ce même package est supprimé de son profil par l'utilisateur. Il est donc important de toujours s'assurer que notre nom de package que nous créons est disponible sur le repo souhaité et qu'il le restera pendant le développement de celui-ci. Pour faciliter cela, Nexus propose une solution qui va provisionner notre nom de package sur notre profil pour éviter de le voir utilisé par un autre utilisateur entre temps.","Nexus va alors créé un petit package vide, portant la version 0.0.0 et va le publier sur notre profil pour réserver le nom. Il est possible de préciser l'url du repo avec l'argument --url"]}],[{"l":"Compilation","p":["Nexus propose un système de compilation basé sur une intégration de cx_freeze grâce à ma commande compile","Les options de compilation sont à retrouver dans le fichier nexus.toml","Avant la compilation, le système va contrôler la présence de toutes les dépendances et leur compatibilité."]},{"l":"Options","p":["pour installer ou mettre à jour les dépendances manquantes pour désactiver la vérification du contrôle de dépendances pour afficher les informations de compilation sans action ou pour préciser l'environnement qui sera utilisé pour la compilation"]}],[{"l":"Analyse","p":["La commande analyse est une intégration de l'outil pylint qui permet d'analyser le code dans le but de déterminer la qualité du code et de proposer des axes d'améliorations pour se rapprocher des recommandations PEP. L'analyse va alors nous ressortir la liste des éléments à modifier dans notre code, ainsi qu'une note sur 10 qui sera base en fonction du nombre de problème à corriger."]},{"l":"Options","p":["ou permet d'exclure de l'analyse certains composants. Par exemple, E0602 pour les undefined variable ou permet d'afficher uniquement la note ou permet d'afficher uniquement les choses à modifier (sans la note) permet d'analyser les fichiers .py qui se trouve dans les répertoires. Cela rendra l'analyse plus longue mais plus complète dans le cas de code complexe."]}],[{"l":"Securiscan","p":["La commande securiscan est une intégration de l'outil Bandit qui permet de détecter les problèmes de sécurité courants. Cette option ne remplace pas un réel outil d'analyse de la sécurité de votre code mais propose une premier niveau d'analyse durant votre développement.","Suite à l'analyse, la commande retournera différents niveaux de détails sur les erreurs à corriger tels que le nom du fichier, le niveau de criticité, l'emplacement de l'erreur ou encore des liens vers les informations détaillées sur la faille ciblée."]},{"l":"Options","p":["ou affichera les erreurs d'analyse ou affichera les totales des métriques suite à l'analyse. Par exemple, le nombre de faille HIGH, MEDIUM ou LOW ou affichera les métriques par fichier. ou affichera l'ensemble des métriques. ou affichera le détail des résultats comme les erreurs à corriger tels que le nom du fichier, le niveau de criticité, l'emplacement de l'erreur ou encore des liens vers les informations détaillées sur la faille ciblée. ou affichera l'ensemble des informations. ou permet d'analyser les fichiers .py qui se trouve dans les répertoires. Cela rendra l'analyse plus longue mais plus complète dans le cas de code complexe. ou permet d'exclure certains fichiers de l'analyse ou permet de filtrer par niveau de severity 1: LOW, 2: MEDIUM, 3: HIGH ou permet de filtrer par niveau de confidence 1: LOW, 2: MEDIUM, 3: HIGH"]}],[{"l":"Clearcode","p":["La commande clearcode est une intégration de l'outil Black qui permet d'analyser et de corriger le formatage du code.","Par défaut, la commande va analyser l'ensemble des fichiers .py se trouvant dans le répertoire courant et retourner les modifications dans le prompt. Il est possible de préciser un ou plusieurs fichiers en particulier pour l'analyse."]},{"l":"Options","p":["permet d'appliquer les modifications directement sur les fichiers analysés Cela permettra de corriger le formatage du code sans étape intermédiaire. permet de spécifier un fichier de sortie. Les fichiers modifiés seront alors placés dans un autre fichier pour permettre une analyse plus simple des modifications. ou permet d'analyser les fichiers .py qui se trouve dans les répertoires. Cela rendra l'analyse plus longue mais plus complète dans le cas de code complexe. permet de faire une analyse rapide du code, qui sera moins précise qu'une analyse complète, mais qui prendra beaucoup moins de temps sur des volumes de code conséquents."]}],[{"l":"Repository","p":["Nexus propose un système de repository git interne pour permettre de versionner son code et ces changements sans avoir besoin d'installer des outils tierces."]}],[{"l":"Initialisation du repo","p":["Dans le cas où le repo n'a pas été créé avec le projet, il est possible de l'initialiser à n'importe quel moment avec la commande","La commande va alors créer un repo avec une branche master."]}],[{"l":"Suppression du repo","p":["Dans le cas où le repo n'est pas utilisé, il est possible de le supprimer du projet avec la commande","La commande va alors supprimer l'intégralité du repo et de son historique."]}],[{"l":"Statut du repo","p":["A tout moment, il est possible d'afficher le statut du repo avec la commande","La commande va alors afficher:","Le nom de la branche active","L'ID du dernier commit","La date du dernier commit","L'auteur","Le nom du committer","Le message de commit","La liste des fichiers qui ont des statuts spécifiques comme des fichiers untracked ou en conflit"]}],[{"l":"Log du repo","p":["Il est possible d'afficher les logs pour repo pour connaître par exemple les derniers commit avec la commande","ou pour afficher chaque commit sur une ligne condensée"]}],[{"l":"Lister les branches","p":["Il est possible de lister les branches du repo en appelant simplement la commande","La commande affichera alors la liste des branches et ajoutera un * devant le nom de la branche active."]}],[{"l":"Ajouter une branche","p":["En fonction de la configuration Nexus, les branches seront automatiquement créées en même temps que les changements de version, mais il est possible de rajouter des branches à volonté avec la commande","La branche sera alors créée mais ne passera pas en branche active."]},{"l":"Options","p":["ou pour définir la branche source. La nouvelle branche partira alors de cette branche ou pour spécifier l'id du commit source. La nouvelle branche partira alors de ce commit"]}],[{"l":"Supprimer une branche","p":["Il est possible de supprimer une branche du repo avec la commande","La branche supprimée ne doit pas être la branche active"]}],[{"l":"Changer de branche","p":["Pour changer de branche rapidement, il suffit d'utiliser la commande","ou s'occupera de créer la branche si celle-ci n'existe pas"]}],[{"l":"Renommer une branche","p":["Il est possible de renommer une branche existante avec la commande","Si l'argument NEW_NAME n'est pas donné, la commande demandera le nouveau nom dans un prompt."]}],[{"l":"Merge des branches","p":["Sur des projets disposant de plusieurs branches, il est possible de merge plusieurs branches pour assembler les modifications. Pour cela, on peut utiliser la commande","La branche choisie sera alors merge dans la branche active."]},{"l":"Options","p":["ou permet de préciser la branche de destination. Cela permet de merge deux branches sans toucher à la branche active."]}],[{"l":"Réinitialisation de commit","p":["La commande nous permet de revenir à un commit précédent tout en annulant les modifications actuelles.","Il existe alors 3 modes de reset"]},{"l":"Options","p":["Toutes les modifications dans l'index intermédiaire et le répertoire de travail seront réinitialisées La référence pointe vers le commit choisi sans toucher à l'index intermédiaire ou au répertoire de travail L'index intermédiaire est réinitialisé et les modifications en attente sont déplacées vers le répertoire de travail"]}],[{"i":"restauration-dun-fichier","l":"Restauration d'un fichier","p":["Sans restaurer entièrement une branche, Nexus propose une commande pour restaurer un fichier ou un répertoire d'un ancien commit.","Par défaut, le fichier sera récupéré depuis le dernier commit et sera restauré à son emplacement d'origine."]},{"l":"Options","p":["ou pour préciser l'emplacement de la restauration ou pour préciser un commit spécifique"]}],[{"l":"Commit des changements","p":["Pour sauvegarder ces changements sur un repo, nous pouvons utiliser la commande .","Par défaut, un prompt demandera le message de commit et ajoutera les changements dans la branche active."]},{"l":"Options","p":["ou pour spécifier le message de commit ou pour spécifier la branche a utilisée"]}],[{"l":"Arborescence du repo","p":["Il est possible d'afficher l'arborescence du commit actuel avec la commande","ou pour spécifier le commit a utilisé. Dans ce cas, il affichera l'arborescence de fichier du commit choisi."]}],[{"l":"Sauvegarde","p":["Pour faciliter l'archivage ou la sauvegarde de nos projets, Nexus propose une solution de sauvegarde qui va archiver et compresser dans un zip l'ensemble de notre projet.","La solution va alors récupérer le code du projet, les include_files, la licence, le readme, le changelog et l'ajouter dans une archive."]},{"i":"options","l":"Options:","p":["ou pour configurer la qualité de compression (entre 1 et 9) ou pour définir le nom de l'archive ou pour forcer l'écriture sur le fichier de sortie"]}],[{"l":"Cache","p":["Pour gagner en réactivité et en temps de traitement, Nexus propose un système de cache pour sauvegarder les informations sur les packages. Ces informations pourront alors être réutilisées par les autres commandes sans avoir besoin de réinterroger les repos.","Pour connaître la capacité du cache à l'instant T, il suffit d'appeler la commande","Celle-ci retournera l'espace de stockage utilisé, le nombre de package et le nombre de version différente stockés.","Il est également possible de lister les packages et leur version stockée dans le cache avec l'argument ou"]}]]